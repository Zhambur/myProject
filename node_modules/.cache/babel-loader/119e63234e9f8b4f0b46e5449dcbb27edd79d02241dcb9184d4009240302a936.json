{"ast":null,"code":"/*!\n * wordcloud2.js\n * http://timdream.org/wordcloud2.js/\n *\n * Copyright 2011 - 2019 Tim Guan-tin Chien and contributors.\n * Released under the MIT license\n */\n\n'use strict';\n\n// setImmediate\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport \"core-js/modules/web.immediate.js\";\nif (!window.setImmediate) {\n  window.setImmediate = function setupSetImmediate() {\n    return window.msSetImmediate || window.webkitSetImmediate || window.mozSetImmediate || window.oSetImmediate || function setupSetZeroTimeout() {\n      if (!window.postMessage || !window.addEventListener) {\n        return null;\n      }\n      var callbacks = [undefined];\n      var message = 'zero-timeout-message';\n\n      // Like setTimeout, but only takes a function argument.  There's\n      // no time argument (always zero) and no arguments (you have to\n      // use a closure).\n      var setZeroTimeout = function setZeroTimeout(callback) {\n        var id = callbacks.length;\n        callbacks.push(callback);\n        window.postMessage(message + id.toString(36), '*');\n        return id;\n      };\n      window.addEventListener('message', function setZeroTimeoutMessage(evt) {\n        // Skipping checking event source, retarded IE confused this window\n        // object with another in the presence of iframe\n        if (typeof evt.data !== 'string' || evt.data.substr(0, message.length) !== message /* ||\n                                                                                           evt.source !== window */) {\n          return;\n        }\n        evt.stopImmediatePropagation();\n        var id = parseInt(evt.data.substr(message.length), 36);\n        if (!callbacks[id]) {\n          return;\n        }\n        callbacks[id]();\n        callbacks[id] = undefined;\n      }, true);\n\n      /* specify clearImmediate() here since we need the scope */\n      window.clearImmediate = function clearZeroTimeout(id) {\n        if (!callbacks[id]) {\n          return;\n        }\n        callbacks[id] = undefined;\n      };\n      return setZeroTimeout;\n    }() ||\n    // fallback\n    function setImmediateFallback(fn) {\n      window.setTimeout(fn, 0);\n    };\n  }();\n}\nif (!window.clearImmediate) {\n  window.clearImmediate = function setupClearImmediate() {\n    return window.msClearImmediate || window.webkitClearImmediate || window.mozClearImmediate || window.oClearImmediate ||\n    // \"clearZeroTimeout\" is implement on the previous block ||\n    // fallback\n    function clearImmediateFallback(timer) {\n      window.clearTimeout(timer);\n    };\n  }();\n}\n\n// Check if WordCloud can run on this browser\nvar isSupported = function isSupported() {\n  var canvas = document.createElement('canvas');\n  if (!canvas || !canvas.getContext) {\n    return false;\n  }\n  var ctx = canvas.getContext('2d');\n  if (!ctx) {\n    return false;\n  }\n  if (!ctx.getImageData) {\n    return false;\n  }\n  if (!ctx.fillText) {\n    return false;\n  }\n  if (!Array.prototype.some) {\n    return false;\n  }\n  if (!Array.prototype.push) {\n    return false;\n  }\n  return true;\n}();\n\n// Find out if the browser impose minium font size by\n// drawing small texts on a canvas and measure it's width.\nvar minFontSize = function getMinFontSize() {\n  if (!isSupported) {\n    return;\n  }\n  var ctx = document.createElement('canvas').getContext('2d');\n\n  // start from 20\n  var size = 20;\n\n  // two sizes to measure\n  var hanWidth, mWidth;\n  while (size) {\n    ctx.font = size.toString(10) + 'px sans-serif';\n    if (ctx.measureText('\\uFF37').width === hanWidth && ctx.measureText('m').width === mWidth) {\n      return size + 1;\n    }\n    hanWidth = ctx.measureText('\\uFF37').width;\n    mWidth = ctx.measureText('m').width;\n    size--;\n  }\n  return 0;\n}();\nvar getItemExtraData = function (item) {\n  if (Array.isArray(item)) {\n    var itemCopy = item.slice();\n    // remove data we already have (word and weight)\n    itemCopy.splice(0, 2);\n    return itemCopy;\n  } else {\n    return [];\n  }\n};\n\n// Based on http://jsfromhell.com/array/shuffle\nvar shuffleArray = function shuffleArray(arr) {\n  for (var j, x, i = arr.length; i;) {\n    j = Math.floor(Math.random() * i);\n    x = arr[--i];\n    arr[i] = arr[j];\n    arr[j] = x;\n  }\n  return arr;\n};\nvar timer = {};\nvar WordCloud = function WordCloud(elements, options) {\n  if (!isSupported) {\n    return;\n  }\n  var timerId = Math.floor(Math.random() * Date.now());\n  if (!Array.isArray(elements)) {\n    elements = [elements];\n  }\n  elements.forEach(function (el, i) {\n    if (typeof el === 'string') {\n      elements[i] = document.getElementById(el);\n      if (!elements[i]) {\n        throw new Error('The element id specified is not found.');\n      }\n    } else if (!el.tagName && !el.appendChild) {\n      throw new Error('You must pass valid HTML elements, or ID of the element.');\n    }\n  });\n\n  /* Default values to be overwritten by options object */\n  var settings = {\n    list: [],\n    fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' + '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n    fontWeight: 'normal',\n    color: 'random-dark',\n    minSize: 0,\n    // 0 to disable\n    weightFactor: 1,\n    clearCanvas: true,\n    backgroundColor: '#fff',\n    // opaque white = rgba(255, 255, 255, 1)\n\n    gridSize: 8,\n    drawOutOfBound: false,\n    shrinkToFit: false,\n    origin: null,\n    drawMask: false,\n    maskColor: 'rgba(255,0,0,0.3)',\n    maskGapWidth: 0.3,\n    layoutAnimation: true,\n    wait: 0,\n    abortThreshold: 0,\n    // disabled\n    abort: function noop() {},\n    minRotation: -Math.PI / 2,\n    maxRotation: Math.PI / 2,\n    rotationStep: 0.1,\n    shuffle: true,\n    rotateRatio: 0.1,\n    shape: 'circle',\n    ellipticity: 0.65,\n    classes: null,\n    hover: null,\n    click: null\n  };\n  if (options) {\n    for (var key in options) {\n      if (key in settings) {\n        settings[key] = options[key];\n      }\n    }\n  }\n\n  /* Convert weightFactor into a function */\n  if (typeof settings.weightFactor !== 'function') {\n    var factor = settings.weightFactor;\n    settings.weightFactor = function weightFactor(pt) {\n      return pt * factor; // in px\n    };\n  }\n\n  /* Convert shape into a function */\n  if (typeof settings.shape !== 'function') {\n    switch (settings.shape) {\n      case 'circle':\n      /* falls through */\n      default:\n        // 'circle' is the default and a shortcut in the code loop.\n        settings.shape = 'circle';\n        break;\n      case 'cardioid':\n        settings.shape = function shapeCardioid(theta) {\n          return 1 - Math.sin(theta);\n        };\n        break;\n\n      /*\n        To work out an X-gon, one has to calculate \"m\",\n        where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n        http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n        2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n        Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n        where t' equals to mod(t, 2PI/X);\n        */\n\n      case 'diamond':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n        // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n        // +0+..+2*PI\n        settings.shape = function shapeSquare(theta) {\n          var thetaPrime = theta % (2 * Math.PI / 4);\n          return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n        };\n        break;\n      case 'square':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+min(1%2Fabs(cos(t\n        // )),1%2Fabs(sin(t)))),+t+%3D+0+..+2*PI\n        settings.shape = function shapeSquare(theta) {\n          return Math.min(1 / Math.abs(Math.cos(theta)), 1 / Math.abs(Math.sin(theta)));\n        };\n        break;\n      case 'triangle-forward':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n        // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n        // %29%29%2C+t+%3D+0+..+2*PI\n        settings.shape = function shapeTriangle(theta) {\n          var thetaPrime = theta % (2 * Math.PI / 3);\n          return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n        };\n        break;\n      case 'triangle':\n      case 'triangle-upright':\n        settings.shape = function shapeTriangle(theta) {\n          var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);\n          return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n        };\n        break;\n      case 'pentagon':\n        settings.shape = function shapePentagon(theta) {\n          var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);\n          return 1 / (Math.cos(thetaPrime) + 0.726543 * Math.sin(thetaPrime));\n        };\n        break;\n      case 'star':\n        settings.shape = function shapeStar(theta) {\n          var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);\n          if ((theta + 0.955) % (2 * Math.PI / 5) - 2 * Math.PI / 10 >= 0) {\n            return 1 / (Math.cos(2 * Math.PI / 10 - thetaPrime) + 3.07768 * Math.sin(2 * Math.PI / 10 - thetaPrime));\n          } else {\n            return 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));\n          }\n        };\n        break;\n    }\n  }\n\n  /* Make sure gridSize is a whole number and is not smaller than 4px */\n  settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\n\n  /* shorthand */\n  var g = settings.gridSize;\n  var maskRectWidth = g - settings.maskGapWidth;\n\n  /* normalize rotation settings */\n  var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\n  var minRotation = Math.min(settings.maxRotation, settings.minRotation);\n  var rotationStep = settings.rotationStep;\n\n  /* information/object available to all functions, set when start() */\n  var grid,\n    // 2d array containing filling information\n    ngx, ngy,\n    // width and height of the grid\n    center,\n    // position of the center of the cloud\n    maxRadius;\n\n  /* timestamp for measuring each putWord() action */\n  var escapeTime;\n\n  /* function for getting the color of the text */\n  var getTextColor;\n  function randomHslColor(min, max) {\n    return 'hsl(' + (Math.random() * 360).toFixed() + ',' + (Math.random() * 30 + 70).toFixed() + '%,' + (Math.random() * (max - min) + min).toFixed() + '%)';\n  }\n  switch (settings.color) {\n    case 'random-dark':\n      getTextColor = function getRandomDarkColor() {\n        return randomHslColor(10, 50);\n      };\n      break;\n    case 'random-light':\n      getTextColor = function getRandomLightColor() {\n        return randomHslColor(50, 90);\n      };\n      break;\n    default:\n      if (typeof settings.color === 'function') {\n        getTextColor = settings.color;\n      }\n      break;\n  }\n\n  /* function for getting the font-weight of the text */\n  var getTextFontWeight;\n  if (typeof settings.fontWeight === 'function') {\n    getTextFontWeight = settings.fontWeight;\n  }\n\n  /* function for getting the classes of the text */\n  var getTextClasses = null;\n  if (typeof settings.classes === 'function') {\n    getTextClasses = settings.classes;\n  }\n\n  /* Interactive */\n  var interactive = false;\n  var infoGrid = [];\n  var hovered;\n  var getInfoGridFromMouseTouchEvent = function getInfoGridFromMouseTouchEvent(evt) {\n    var canvas = evt.currentTarget;\n    var rect = canvas.getBoundingClientRect();\n    var clientX;\n    var clientY;\n    /** Detect if touches are available */\n    if (evt.touches) {\n      clientX = evt.touches[0].clientX;\n      clientY = evt.touches[0].clientY;\n    } else {\n      clientX = evt.clientX;\n      clientY = evt.clientY;\n    }\n    var eventX = clientX - rect.left;\n    var eventY = clientY - rect.top;\n    var x = Math.floor(eventX * (canvas.width / rect.width || 1) / g);\n    var y = Math.floor(eventY * (canvas.height / rect.height || 1) / g);\n    if (!infoGrid[x]) {\n      return null;\n    }\n    return infoGrid[x][y];\n  };\n  var wordcloudhover = function wordcloudhover(evt) {\n    var info = getInfoGridFromMouseTouchEvent(evt);\n    if (hovered === info) {\n      return;\n    }\n    hovered = info;\n    if (!info) {\n      settings.hover(undefined, undefined, evt);\n      return;\n    }\n    settings.hover(info.item, info.dimension, evt);\n  };\n  var wordcloudclick = function wordcloudclick(evt) {\n    var info = getInfoGridFromMouseTouchEvent(evt);\n    if (!info) {\n      return;\n    }\n    settings.click(info.item, info.dimension, evt);\n    evt.preventDefault();\n  };\n\n  /* Get points on the grid for a given radius away from the center */\n  var pointsAtRadius = [];\n  var getPointsAtRadius = function getPointsAtRadius(radius) {\n    if (pointsAtRadius[radius]) {\n      return pointsAtRadius[radius];\n    }\n\n    // Look for these number of points on each radius\n    var T = radius * 8;\n\n    // Getting all the points at this radius\n    var t = T;\n    var points = [];\n    if (radius === 0) {\n      points.push([center[0], center[1], 0]);\n    }\n    while (t--) {\n      // distort the radius to put the cloud in shape\n      var rx = 1;\n      if (settings.shape !== 'circle') {\n        rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1\n      }\n\n      // Push [x, y, t]; t is used solely for getTextColor()\n      points.push([center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI), center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) * settings.ellipticity, t / T * 2 * Math.PI]);\n    }\n    pointsAtRadius[radius] = points;\n    return points;\n  };\n\n  /* Return true if we had spent too much time */\n  var exceedTime = function exceedTime() {\n    return settings.abortThreshold > 0 && new Date().getTime() - escapeTime > settings.abortThreshold;\n  };\n\n  /* Get the deg of rotation according to settings, and luck. */\n  var getRotateDeg = function getRotateDeg() {\n    if (settings.rotateRatio === 0) {\n      return 0;\n    }\n    if (Math.random() > settings.rotateRatio) {\n      return 0;\n    }\n    if (rotationRange === 0) {\n      return minRotation;\n    }\n    return minRotation + Math.round(Math.random() * rotationRange / rotationStep) * rotationStep;\n  };\n  var getTextInfo = function getTextInfo(word, weight, rotateDeg, extraDataArray) {\n    // calculate the acutal font size\n    // fontSize === 0 means weightFactor function wants the text skipped,\n    // and size < minSize means we cannot draw the text.\n    var debug = false;\n    var fontSize = settings.weightFactor(weight);\n    if (fontSize <= settings.minSize) {\n      return false;\n    }\n\n    // Scale factor here is to make sure fillText is not limited by\n    // the minium font size set by browser.\n    // It will always be 1 or 2n.\n    var mu = 1;\n    if (fontSize < minFontSize) {\n      mu = function calculateScaleFactor() {\n        var mu = 2;\n        while (mu * fontSize < minFontSize) {\n          mu += 2;\n        }\n        return mu;\n      }();\n    }\n\n    // Get fontWeight that will be used to set fctx.font\n    var fontWeight;\n    if (getTextFontWeight) {\n      fontWeight = getTextFontWeight(word, weight, fontSize, extraDataArray);\n    } else {\n      fontWeight = settings.fontWeight;\n    }\n    var fcanvas = document.createElement('canvas');\n    var fctx = fcanvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    fctx.font = fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n\n    // Estimate the dimension of the text with measureText().\n    var fw = fctx.measureText(word).width / mu;\n    var fh = Math.max(fontSize * mu, fctx.measureText('m').width, fctx.measureText('\\uFF37').width) / mu;\n\n    // Create a boundary box that is larger than our estimates,\n    // so text don't get cut of (it sill might)\n    var boxWidth = fw + fh * 2;\n    var boxHeight = fh * 3;\n    var fgw = Math.ceil(boxWidth / g);\n    var fgh = Math.ceil(boxHeight / g);\n    boxWidth = fgw * g;\n    boxHeight = fgh * g;\n\n    // Calculate the proper offsets to make the text centered at\n    // the preferred position.\n\n    // This is simply half of the width.\n    var fillTextOffsetX = -fw / 2;\n    // Instead of moving the box to the exact middle of the preferred\n    // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n    // vertical centered.\n    var fillTextOffsetY = -fh * 0.4;\n\n    // Calculate the actual dimension of the canvas, considering the rotation.\n    var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) + boxHeight * Math.abs(Math.cos(rotateDeg))) / g);\n    var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) + boxHeight * Math.abs(Math.sin(rotateDeg))) / g);\n    var width = cgw * g;\n    var height = cgh * g;\n    fcanvas.setAttribute('width', width);\n    fcanvas.setAttribute('height', height);\n    if (debug) {\n      // Attach fcanvas to the DOM\n      document.body.appendChild(fcanvas);\n      // Save it's state so that we could restore and draw the grid correctly.\n      fctx.save();\n    }\n\n    // Scale the canvas with |mu|.\n    fctx.scale(1 / mu, 1 / mu);\n    fctx.translate(width * mu / 2, height * mu / 2);\n    fctx.rotate(-rotateDeg);\n\n    // Once the width/height is set, ctx info will be reset.\n    // Set it again here.\n    fctx.font = fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n\n    // Fill the text into the fcanvas.\n    // XXX: We cannot because textBaseline = 'top' here because\n    // Firefox and Chrome uses different default line-height for canvas.\n    // Please read https://bugzil.la/737852#c6.\n    // Here, we use textBaseline = 'middle' and draw the text at exactly\n    // 0.5 * fontSize lower.\n    fctx.fillStyle = '#000';\n    fctx.textBaseline = 'middle';\n    fctx.fillText(word, fillTextOffsetX * mu, (fillTextOffsetY + fontSize * 0.5) * mu);\n\n    // Get the pixels of the text\n    var imageData = fctx.getImageData(0, 0, width, height).data;\n    if (exceedTime()) {\n      return false;\n    }\n    if (debug) {\n      // Draw the box of the original estimation\n      fctx.strokeRect(fillTextOffsetX * mu, fillTextOffsetY, fw * mu, fh * mu);\n      fctx.restore();\n    }\n\n    // Read the pixels and save the information to the occupied array\n    var occupied = [];\n    var gx = cgw;\n    var gy, x, y;\n    var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\n    while (gx--) {\n      gy = cgh;\n      while (gy--) {\n        y = g;\n        /* eslint no-labels: ['error', { 'allowLoop': true }] */\n        singleGridLoop: while (y--) {\n          x = g;\n          while (x--) {\n            if (imageData[((gy * g + y) * width + (gx * g + x)) * 4 + 3]) {\n              occupied.push([gx, gy]);\n              if (gx < bounds[3]) {\n                bounds[3] = gx;\n              }\n              if (gx > bounds[1]) {\n                bounds[1] = gx;\n              }\n              if (gy < bounds[0]) {\n                bounds[0] = gy;\n              }\n              if (gy > bounds[2]) {\n                bounds[2] = gy;\n              }\n              if (debug) {\n                fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n              }\n              break singleGridLoop;\n            }\n          }\n        }\n        if (debug) {\n          fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n          fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n        }\n      }\n    }\n    if (debug) {\n      fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n      fctx.fillRect(bounds[3] * g, bounds[0] * g, (bounds[1] - bounds[3] + 1) * g, (bounds[2] - bounds[0] + 1) * g);\n    }\n\n    // Return information needed to create the text on the real canvas\n    return {\n      mu: mu,\n      occupied: occupied,\n      bounds: bounds,\n      gw: cgw,\n      gh: cgh,\n      fillTextOffsetX: fillTextOffsetX,\n      fillTextOffsetY: fillTextOffsetY,\n      fillTextWidth: fw,\n      fillTextHeight: fh,\n      fontSize: fontSize\n    };\n  };\n\n  /* Determine if there is room available in the given dimension */\n  var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\n    // Go through the occupied points,\n    // return false if the space is not available.\n    var i = occupied.length;\n    while (i--) {\n      var px = gx + occupied[i][0];\n      var py = gy + occupied[i][1];\n      if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n        if (!settings.drawOutOfBound) {\n          return false;\n        }\n        continue;\n      }\n      if (!grid[px][py]) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  /* Actually draw the text on the grid */\n  var drawText = function drawText(gx, gy, info, word, weight, distance, theta, rotateDeg, attributes, extraDataArray) {\n    var fontSize = info.fontSize;\n    var color;\n    if (getTextColor) {\n      color = getTextColor(word, weight, fontSize, distance, theta, extraDataArray);\n    } else {\n      color = settings.color;\n    }\n\n    // get fontWeight that will be used to set ctx.font and font style rule\n    var fontWeight;\n    if (getTextFontWeight) {\n      fontWeight = getTextFontWeight(word, weight, fontSize, extraDataArray);\n    } else {\n      fontWeight = settings.fontWeight;\n    }\n    var classes;\n    if (getTextClasses) {\n      classes = getTextClasses(word, weight, fontSize, extraDataArray);\n    } else {\n      classes = settings.classes;\n    }\n    elements.forEach(function (el) {\n      if (el.getContext) {\n        var ctx = el.getContext('2d');\n        var mu = info.mu;\n\n        // Save the current state before messing it\n        ctx.save();\n        ctx.scale(1 / mu, 1 / mu);\n        ctx.font = fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n        ctx.fillStyle = color;\n\n        // Translate the canvas position to the origin coordinate of where\n        // the text should be put.\n        ctx.translate((gx + info.gw / 2) * g * mu, (gy + info.gh / 2) * g * mu);\n        if (rotateDeg !== 0) {\n          ctx.rotate(-rotateDeg);\n        }\n\n        // Finally, fill the text.\n\n        // XXX: We cannot because textBaseline = 'top' here because\n        // Firefox and Chrome uses different default line-height for canvas.\n        // Please read https://bugzil.la/737852#c6.\n        // Here, we use textBaseline = 'middle' and draw the text at exactly\n        // 0.5 * fontSize lower.\n        ctx.textBaseline = 'middle';\n        ctx.fillText(word, info.fillTextOffsetX * mu, (info.fillTextOffsetY + fontSize * 0.5) * mu);\n\n        // The below box is always matches how <span>s are positioned\n        /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n            info.fillTextWidth, info.fillTextHeight); */\n\n        // Restore the state.\n        ctx.restore();\n      } else {\n        // drawText on DIV element\n        var span = document.createElement('span');\n        var transformRule = '';\n        transformRule = 'rotate(' + -rotateDeg / Math.PI * 180 + 'deg) ';\n        if (info.mu !== 1) {\n          transformRule += 'translateX(-' + info.fillTextWidth / 4 + 'px) ' + 'scale(' + 1 / info.mu + ')';\n        }\n        var styleRules = {\n          position: 'absolute',\n          display: 'block',\n          font: fontWeight + ' ' + fontSize * info.mu + 'px ' + settings.fontFamily,\n          left: (gx + info.gw / 2) * g + info.fillTextOffsetX + 'px',\n          top: (gy + info.gh / 2) * g + info.fillTextOffsetY + 'px',\n          width: info.fillTextWidth + 'px',\n          height: info.fillTextHeight + 'px',\n          lineHeight: fontSize + 'px',\n          whiteSpace: 'nowrap',\n          transform: transformRule,\n          webkitTransform: transformRule,\n          msTransform: transformRule,\n          transformOrigin: '50% 40%',\n          webkitTransformOrigin: '50% 40%',\n          msTransformOrigin: '50% 40%'\n        };\n        if (color) {\n          styleRules.color = color;\n        }\n        span.textContent = word;\n        for (var cssProp in styleRules) {\n          span.style[cssProp] = styleRules[cssProp];\n        }\n        if (attributes) {\n          for (var attribute in attributes) {\n            span.setAttribute(attribute, attributes[attribute]);\n          }\n        }\n        if (classes) {\n          span.className += classes;\n        }\n        el.appendChild(span);\n      }\n    });\n  };\n\n  /* Help function to updateGrid */\n  var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\n    if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n      return;\n    }\n    grid[x][y] = false;\n    if (drawMask) {\n      var ctx = elements[0].getContext('2d');\n      ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\n    }\n    if (interactive) {\n      infoGrid[x][y] = {\n        item: item,\n        dimension: dimension\n      };\n    }\n  };\n\n  /* Update the filling information of the given space with occupied points.\n       Draw the mask on the canvas if necessary. */\n  var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {\n    var occupied = info.occupied;\n    var drawMask = settings.drawMask;\n    var ctx;\n    if (drawMask) {\n      ctx = elements[0].getContext('2d');\n      ctx.save();\n      ctx.fillStyle = settings.maskColor;\n    }\n    var dimension;\n    if (interactive) {\n      var bounds = info.bounds;\n      dimension = {\n        x: (gx + bounds[3]) * g,\n        y: (gy + bounds[0]) * g,\n        w: (bounds[1] - bounds[3] + 1) * g,\n        h: (bounds[2] - bounds[0] + 1) * g\n      };\n    }\n    var i = occupied.length;\n    while (i--) {\n      var px = gx + occupied[i][0];\n      var py = gy + occupied[i][1];\n      if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n        continue;\n      }\n      fillGridAt(px, py, drawMask, dimension, item);\n    }\n    if (drawMask) {\n      ctx.restore();\n    }\n  };\n\n  /* putWord() processes each item on the list,\n       calculate it's size and determine it's position, and actually\n       put it on the canvas. */\n  var putWord = function putWord(item, loopIndex) {\n    if (loopIndex > 20) {\n      return null;\n    }\n    var word, weight, attributes;\n    if (Array.isArray(item)) {\n      word = item[0];\n      weight = item[1];\n    } else {\n      word = item.word;\n      weight = item.weight;\n      attributes = item.attributes;\n    }\n    var rotateDeg = getRotateDeg();\n    var extraDataArray = getItemExtraData(item);\n\n    // get info needed to put the text onto the canvas\n    var info = getTextInfo(word, weight, rotateDeg, extraDataArray);\n\n    // not getting the info means we shouldn't be drawing this one.\n    if (!info) {\n      return false;\n    }\n    if (exceedTime()) {\n      return false;\n    }\n\n    // If drawOutOfBound is set to false,\n    // skip the loop if we have already know the bounding box of\n    // word is larger than the canvas.\n    if (!settings.drawOutOfBound && !settings.shrinkToFit) {\n      var bounds = info.bounds;\n      if (bounds[1] - bounds[3] + 1 > ngx || bounds[2] - bounds[0] + 1 > ngy) {\n        return false;\n      }\n    }\n\n    // Determine the position to put the text by\n    // start looking for the nearest points\n    var r = maxRadius + 1;\n    var tryToPutWordAtPoint = function (gxy) {\n      var gx = Math.floor(gxy[0] - info.gw / 2);\n      var gy = Math.floor(gxy[1] - info.gh / 2);\n      var gw = info.gw;\n      var gh = info.gh;\n\n      // If we cannot fit the text at this position, return false\n      // and go to the next position.\n      if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n        return false;\n      }\n\n      // Actually put the text on the canvas\n      drawText(gx, gy, info, word, weight, maxRadius - r, gxy[2], rotateDeg, attributes, extraDataArray);\n\n      // Mark the spaces on the grid as filled\n      updateGrid(gx, gy, gw, gh, info, item);\n      return {\n        gx: gx,\n        gy: gy,\n        rot: rotateDeg,\n        info: info\n      };\n    };\n    while (r--) {\n      var points = getPointsAtRadius(maxRadius - r);\n      if (settings.shuffle) {\n        points = [].concat(points);\n        shuffleArray(points);\n      }\n\n      // Try to fit the words by looking at each point.\n      // array.some() will stop and return true\n      // when putWordAtPoint() returns true.\n      for (var i = 0; i < points.length; i++) {\n        var res = tryToPutWordAtPoint(points[i]);\n        if (res) {\n          return res;\n        }\n      }\n\n      // var drawn = points.some(tryToPutWordAtPoint);\n      // if (drawn) {\n      //   // leave putWord() and return true\n      //   return true;\n      // }\n    }\n    if (settings.shrinkToFit) {\n      if (Array.isArray(item)) {\n        item[1] = item[1] * 3 / 4;\n      } else {\n        item.weight = item.weight * 3 / 4;\n      }\n      return putWord(item, loopIndex + 1);\n    }\n\n    // we tried all distances but text won't fit, return null\n    return null;\n  };\n\n  /* Send DOM event to all elements. Will stop sending event and return\n       if the previous one is canceled (for cancelable events). */\n  var sendEvent = function sendEvent(type, cancelable, details) {\n    if (cancelable) {\n      return !elements.some(function (el) {\n        var event = new CustomEvent(type, {\n          detail: details || {}\n        });\n        return !el.dispatchEvent(event);\n      }, this);\n    } else {\n      elements.forEach(function (el) {\n        var event = new CustomEvent(type, {\n          detail: details || {}\n        });\n        el.dispatchEvent(event);\n      }, this);\n    }\n  };\n\n  /* Start drawing on a canvas */\n  var start = function start() {\n    // For dimensions, clearCanvas etc.,\n    // we only care about the first element.\n    var canvas = elements[0];\n    if (canvas.getContext) {\n      ngx = Math.ceil(canvas.width / g);\n      ngy = Math.ceil(canvas.height / g);\n    } else {\n      var rect = canvas.getBoundingClientRect();\n      ngx = Math.ceil(rect.width / g);\n      ngy = Math.ceil(rect.height / g);\n    }\n\n    // Sending a wordcloudstart event which cause the previous loop to stop.\n    // Do nothing if the event is canceled.\n    if (!sendEvent('wordcloudstart', true)) {\n      return;\n    }\n\n    // Determine the center of the word cloud\n    center = settings.origin ? [settings.origin[0] / g, settings.origin[1] / g] : [ngx / 2, ngy / 2];\n\n    // Maxium radius to look for space\n    maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\n\n    /* Clear the canvas only if the clearCanvas is set,\n         if not, update the grid to the current canvas state */\n    grid = [];\n    var gx, gy, i;\n    if (!canvas.getContext || settings.clearCanvas) {\n      elements.forEach(function (el) {\n        if (el.getContext) {\n          var ctx = el.getContext('2d');\n          ctx.fillStyle = settings.backgroundColor;\n          ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n          ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n        } else {\n          el.textContent = '';\n          el.style.backgroundColor = settings.backgroundColor;\n          el.style.position = 'relative';\n        }\n      });\n\n      /* fill the grid with empty state */\n      gx = ngx;\n      while (gx--) {\n        grid[gx] = [];\n        gy = ngy;\n        while (gy--) {\n          grid[gx][gy] = true;\n        }\n      }\n    } else {\n      /* Determine bgPixel by creating\n           another canvas and fill the specified background color. */\n      var bctx = document.createElement('canvas').getContext('2d');\n      bctx.fillStyle = settings.backgroundColor;\n      bctx.fillRect(0, 0, 1, 1);\n      var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\n\n      /* Read back the pixels of the canvas we got to tell which part of the\n           canvas is empty.\n           (no clearCanvas only works with a canvas, not divs) */\n      var imageData = canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;\n      gx = ngx;\n      var x, y;\n      while (gx--) {\n        grid[gx] = [];\n        gy = ngy;\n        while (gy--) {\n          y = g;\n          /* eslint no-labels: ['error', { 'allowLoop': true }] */\n          singleGridLoop: while (y--) {\n            x = g;\n            while (x--) {\n              i = 4;\n              while (i--) {\n                if (imageData[((gy * g + y) * ngx * g + (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                  grid[gx][gy] = false;\n                  break singleGridLoop;\n                }\n              }\n            }\n          }\n          if (grid[gx][gy] !== false) {\n            grid[gx][gy] = true;\n          }\n        }\n      }\n      imageData = bctx = bgPixel = undefined;\n    }\n\n    // fill the infoGrid with empty state if we need it\n    if (settings.hover || settings.click) {\n      interactive = true;\n\n      /* fill the grid with empty state */\n      gx = ngx + 1;\n      while (gx--) {\n        infoGrid[gx] = [];\n      }\n      if (settings.hover) {\n        canvas.addEventListener('mousemove', wordcloudhover);\n      }\n      if (settings.click) {\n        canvas.addEventListener('click', wordcloudclick);\n        canvas.addEventListener('touchstart', wordcloudclick);\n        canvas.addEventListener('touchend', function (e) {\n          e.preventDefault();\n        });\n        canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n      }\n      canvas.addEventListener('wordcloudstart', function stopInteraction() {\n        canvas.removeEventListener('wordcloudstart', stopInteraction);\n        canvas.removeEventListener('mousemove', wordcloudhover);\n        canvas.removeEventListener('click', wordcloudclick);\n        hovered = undefined;\n      });\n    }\n    i = 0;\n    var loopingFunction, stoppingFunction;\n    var layouting = true;\n    if (!settings.layoutAnimation) {\n      loopingFunction = function (cb) {\n        cb();\n      };\n      stoppingFunction = function () {\n        layouting = false;\n      };\n    } else if (settings.wait !== 0) {\n      loopingFunction = window.setTimeout;\n      stoppingFunction = window.clearTimeout;\n    } else {\n      loopingFunction = window.setImmediate;\n      stoppingFunction = window.clearImmediate;\n    }\n    var addEventListener = function addEventListener(type, listener) {\n      elements.forEach(function (el) {\n        el.addEventListener(type, listener);\n      }, this);\n    };\n    var removeEventListener = function removeEventListener(type, listener) {\n      elements.forEach(function (el) {\n        el.removeEventListener(type, listener);\n      }, this);\n    };\n    var anotherWordCloudStart = function anotherWordCloudStart() {\n      removeEventListener('wordcloudstart', anotherWordCloudStart);\n      stoppingFunction(timer[timerId]);\n    };\n    addEventListener('wordcloudstart', anotherWordCloudStart);\n\n    // At least wait the following code before call the first iteration.\n    timer[timerId] = (settings.layoutAnimation ? loopingFunction : setTimeout)(function loop() {\n      if (!layouting) {\n        return;\n      }\n      if (i >= settings.list.length) {\n        stoppingFunction(timer[timerId]);\n        sendEvent('wordcloudstop', false);\n        removeEventListener('wordcloudstart', anotherWordCloudStart);\n        delete timer[timerId];\n        return;\n      }\n      escapeTime = new Date().getTime();\n      var drawn = putWord(settings.list[i], 0);\n      var canceled = !sendEvent('wordclouddrawn', true, {\n        item: settings.list[i],\n        drawn: drawn\n      });\n      if (exceedTime() || canceled) {\n        stoppingFunction(timer[timerId]);\n        settings.abort();\n        sendEvent('wordcloudabort', false);\n        sendEvent('wordcloudstop', false);\n        removeEventListener('wordcloudstart', anotherWordCloudStart);\n        return;\n      }\n      i++;\n      timer[timerId] = loopingFunction(loop, settings.wait);\n    }, settings.wait);\n  };\n\n  // All set, start the drawing\n  start();\n};\nWordCloud.isSupported = isSupported;\nWordCloud.minFontSize = minFontSize;\nexport default WordCloud;","map":{"version":3,"names":["window","setImmediate","setupSetImmediate","msSetImmediate","webkitSetImmediate","mozSetImmediate","oSetImmediate","setupSetZeroTimeout","postMessage","addEventListener","callbacks","undefined","message","setZeroTimeout","callback","id","length","push","toString","setZeroTimeoutMessage","evt","data","substr","stopImmediatePropagation","parseInt","clearImmediate","clearZeroTimeout","setImmediateFallback","fn","setTimeout","setupClearImmediate","msClearImmediate","webkitClearImmediate","mozClearImmediate","oClearImmediate","clearImmediateFallback","timer","clearTimeout","isSupported","canvas","document","createElement","getContext","ctx","getImageData","fillText","Array","prototype","some","minFontSize","getMinFontSize","size","hanWidth","mWidth","font","measureText","width","getItemExtraData","item","isArray","itemCopy","slice","splice","shuffleArray","arr","j","x","i","Math","floor","random","WordCloud","elements","options","timerId","Date","now","forEach","el","getElementById","Error","tagName","appendChild","settings","list","fontFamily","fontWeight","color","minSize","weightFactor","clearCanvas","backgroundColor","gridSize","drawOutOfBound","shrinkToFit","origin","drawMask","maskColor","maskGapWidth","layoutAnimation","wait","abortThreshold","abort","noop","minRotation","PI","maxRotation","rotationStep","shuffle","rotateRatio","shape","ellipticity","classes","hover","click","key","factor","pt","shapeCardioid","theta","sin","shapeSquare","thetaPrime","cos","min","abs","shapeTriangle","sqrt","shapePentagon","shapeStar","max","g","maskRectWidth","rotationRange","grid","ngx","ngy","center","maxRadius","escapeTime","getTextColor","randomHslColor","toFixed","getRandomDarkColor","getRandomLightColor","getTextFontWeight","getTextClasses","interactive","infoGrid","hovered","getInfoGridFromMouseTouchEvent","currentTarget","rect","getBoundingClientRect","clientX","clientY","touches","eventX","left","eventY","top","y","height","wordcloudhover","info","dimension","wordcloudclick","preventDefault","pointsAtRadius","getPointsAtRadius","radius","T","t","points","rx","exceedTime","getTime","getRotateDeg","round","getTextInfo","word","weight","rotateDeg","extraDataArray","debug","fontSize","mu","calculateScaleFactor","fcanvas","fctx","willReadFrequently","fw","fh","boxWidth","boxHeight","fgw","ceil","fgh","fillTextOffsetX","fillTextOffsetY","cgh","cgw","setAttribute","body","save","scale","translate","rotate","fillStyle","textBaseline","imageData","strokeRect","restore","occupied","gx","gy","bounds","singleGridLoop","fillRect","gw","gh","fillTextWidth","fillTextHeight","canFitText","px","py","drawText","distance","attributes","span","transformRule","styleRules","position","display","lineHeight","whiteSpace","transform","webkitTransform","msTransform","transformOrigin","webkitTransformOrigin","msTransformOrigin","textContent","cssProp","style","attribute","className","fillGridAt","updateGrid","w","h","putWord","loopIndex","r","tryToPutWordAtPoint","gxy","rot","concat","res","sendEvent","type","cancelable","details","event","CustomEvent","detail","dispatchEvent","start","clearRect","bctx","bgPixel","e","webkitTapHighlightColor","stopInteraction","removeEventListener","loopingFunction","stoppingFunction","layouting","cb","listener","anotherWordCloudStart","loop","drawn","canceled"],"sources":["E:/200_StudyArea/210_curricularStudy/216_junior_down/02_vis_tech/exp/myProject/node_modules/echarts-wordcloud/src/layout.js"],"sourcesContent":["/*!\n * wordcloud2.js\n * http://timdream.org/wordcloud2.js/\n *\n * Copyright 2011 - 2019 Tim Guan-tin Chien and contributors.\n * Released under the MIT license\n */\n\n'use strict';\n\n// setImmediate\nif (!window.setImmediate) {\n  window.setImmediate = (function setupSetImmediate() {\n    return (\n      window.msSetImmediate ||\n      window.webkitSetImmediate ||\n      window.mozSetImmediate ||\n      window.oSetImmediate ||\n      (function setupSetZeroTimeout() {\n        if (!window.postMessage || !window.addEventListener) {\n          return null;\n        }\n\n        var callbacks = [undefined];\n        var message = 'zero-timeout-message';\n\n        // Like setTimeout, but only takes a function argument.  There's\n        // no time argument (always zero) and no arguments (you have to\n        // use a closure).\n        var setZeroTimeout = function setZeroTimeout(callback) {\n          var id = callbacks.length;\n          callbacks.push(callback);\n          window.postMessage(message + id.toString(36), '*');\n\n          return id;\n        };\n\n        window.addEventListener(\n          'message',\n          function setZeroTimeoutMessage(evt) {\n            // Skipping checking event source, retarded IE confused this window\n            // object with another in the presence of iframe\n            if (\n              typeof evt.data !== 'string' ||\n              evt.data.substr(0, message.length) !== message /* ||\n            evt.source !== window */\n            ) {\n              return;\n            }\n\n            evt.stopImmediatePropagation();\n\n            var id = parseInt(evt.data.substr(message.length), 36);\n            if (!callbacks[id]) {\n              return;\n            }\n\n            callbacks[id]();\n            callbacks[id] = undefined;\n          },\n          true\n        );\n\n        /* specify clearImmediate() here since we need the scope */\n        window.clearImmediate = function clearZeroTimeout(id) {\n          if (!callbacks[id]) {\n            return;\n          }\n\n          callbacks[id] = undefined;\n        };\n\n        return setZeroTimeout;\n      })() ||\n      // fallback\n      function setImmediateFallback(fn) {\n        window.setTimeout(fn, 0);\n      }\n    );\n  })();\n}\n\nif (!window.clearImmediate) {\n  window.clearImmediate = (function setupClearImmediate() {\n    return (\n      window.msClearImmediate ||\n      window.webkitClearImmediate ||\n      window.mozClearImmediate ||\n      window.oClearImmediate ||\n      // \"clearZeroTimeout\" is implement on the previous block ||\n      // fallback\n      function clearImmediateFallback(timer) {\n        window.clearTimeout(timer);\n      }\n    );\n  })();\n}\n\n// Check if WordCloud can run on this browser\nvar isSupported = (function isSupported() {\n  var canvas = document.createElement('canvas');\n  if (!canvas || !canvas.getContext) {\n    return false;\n  }\n\n  var ctx = canvas.getContext('2d');\n  if (!ctx) {\n    return false;\n  }\n  if (!ctx.getImageData) {\n    return false;\n  }\n  if (!ctx.fillText) {\n    return false;\n  }\n\n  if (!Array.prototype.some) {\n    return false;\n  }\n  if (!Array.prototype.push) {\n    return false;\n  }\n\n  return true;\n})();\n\n// Find out if the browser impose minium font size by\n// drawing small texts on a canvas and measure it's width.\nvar minFontSize = (function getMinFontSize() {\n  if (!isSupported) {\n    return;\n  }\n\n  var ctx = document.createElement('canvas').getContext('2d');\n\n  // start from 20\n  var size = 20;\n\n  // two sizes to measure\n  var hanWidth, mWidth;\n\n  while (size) {\n    ctx.font = size.toString(10) + 'px sans-serif';\n    if (\n      ctx.measureText('\\uFF37').width === hanWidth &&\n      ctx.measureText('m').width === mWidth\n    ) {\n      return size + 1;\n    }\n\n    hanWidth = ctx.measureText('\\uFF37').width;\n    mWidth = ctx.measureText('m').width;\n\n    size--;\n  }\n\n  return 0;\n})();\n\nvar getItemExtraData = function (item) {\n  if (Array.isArray(item)) {\n    var itemCopy = item.slice();\n    // remove data we already have (word and weight)\n    itemCopy.splice(0, 2);\n    return itemCopy;\n  } else {\n    return [];\n  }\n};\n\n// Based on http://jsfromhell.com/array/shuffle\nvar shuffleArray = function shuffleArray(arr) {\n  for (var j, x, i = arr.length; i; ) {\n    j = Math.floor(Math.random() * i);\n    x = arr[--i];\n    arr[i] = arr[j];\n    arr[j] = x;\n  }\n  return arr;\n};\n\nvar timer = {};\nvar WordCloud = function WordCloud(elements, options) {\n  if (!isSupported) {\n    return;\n  }\n\n  var timerId = Math.floor(Math.random() * Date.now());\n\n  if (!Array.isArray(elements)) {\n    elements = [elements];\n  }\n\n  elements.forEach(function (el, i) {\n    if (typeof el === 'string') {\n      elements[i] = document.getElementById(el);\n      if (!elements[i]) {\n        throw new Error('The element id specified is not found.');\n      }\n    } else if (!el.tagName && !el.appendChild) {\n      throw new Error(\n        'You must pass valid HTML elements, or ID of the element.'\n      );\n    }\n  });\n\n  /* Default values to be overwritten by options object */\n  var settings = {\n    list: [],\n    fontFamily:\n      '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' +\n      '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n    fontWeight: 'normal',\n    color: 'random-dark',\n    minSize: 0, // 0 to disable\n    weightFactor: 1,\n    clearCanvas: true,\n    backgroundColor: '#fff', // opaque white = rgba(255, 255, 255, 1)\n\n    gridSize: 8,\n    drawOutOfBound: false,\n    shrinkToFit: false,\n    origin: null,\n\n    drawMask: false,\n    maskColor: 'rgba(255,0,0,0.3)',\n    maskGapWidth: 0.3,\n\n    layoutAnimation: true,\n\n    wait: 0,\n    abortThreshold: 0, // disabled\n    abort: function noop() {},\n\n    minRotation: -Math.PI / 2,\n    maxRotation: Math.PI / 2,\n    rotationStep: 0.1,\n\n    shuffle: true,\n    rotateRatio: 0.1,\n\n    shape: 'circle',\n    ellipticity: 0.65,\n\n    classes: null,\n\n    hover: null,\n    click: null\n  };\n\n  if (options) {\n    for (var key in options) {\n      if (key in settings) {\n        settings[key] = options[key];\n      }\n    }\n  }\n\n  /* Convert weightFactor into a function */\n  if (typeof settings.weightFactor !== 'function') {\n    var factor = settings.weightFactor;\n    settings.weightFactor = function weightFactor(pt) {\n      return pt * factor; // in px\n    };\n  }\n\n  /* Convert shape into a function */\n  if (typeof settings.shape !== 'function') {\n    switch (settings.shape) {\n      case 'circle':\n      /* falls through */\n      default:\n        // 'circle' is the default and a shortcut in the code loop.\n        settings.shape = 'circle';\n        break;\n\n      case 'cardioid':\n        settings.shape = function shapeCardioid(theta) {\n          return 1 - Math.sin(theta);\n        };\n        break;\n\n      /*\n        To work out an X-gon, one has to calculate \"m\",\n        where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n        http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n        2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n        Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n        where t' equals to mod(t, 2PI/X);\n        */\n\n      case 'diamond':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n        // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n        // +0+..+2*PI\n        settings.shape = function shapeSquare(theta) {\n          var thetaPrime = theta % ((2 * Math.PI) / 4);\n          return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n        };\n        break;\n\n      case 'square':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+min(1%2Fabs(cos(t\n        // )),1%2Fabs(sin(t)))),+t+%3D+0+..+2*PI\n        settings.shape = function shapeSquare(theta) {\n          return Math.min(\n            1 / Math.abs(Math.cos(theta)),\n            1 / Math.abs(Math.sin(theta))\n          );\n        };\n        break;\n\n      case 'triangle-forward':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n        // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n        // %29%29%2C+t+%3D+0+..+2*PI\n        settings.shape = function shapeTriangle(theta) {\n          var thetaPrime = theta % ((2 * Math.PI) / 3);\n          return (\n            1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime))\n          );\n        };\n        break;\n\n      case 'triangle':\n      case 'triangle-upright':\n        settings.shape = function shapeTriangle(theta) {\n          var thetaPrime = (theta + (Math.PI * 3) / 2) % ((2 * Math.PI) / 3);\n          return (\n            1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime))\n          );\n        };\n        break;\n\n      case 'pentagon':\n        settings.shape = function shapePentagon(theta) {\n          var thetaPrime = (theta + 0.955) % ((2 * Math.PI) / 5);\n          return 1 / (Math.cos(thetaPrime) + 0.726543 * Math.sin(thetaPrime));\n        };\n        break;\n\n      case 'star':\n        settings.shape = function shapeStar(theta) {\n          var thetaPrime = (theta + 0.955) % ((2 * Math.PI) / 10);\n          if (\n            ((theta + 0.955) % ((2 * Math.PI) / 5)) - (2 * Math.PI) / 10 >=\n            0\n          ) {\n            return (\n              1 /\n              (Math.cos((2 * Math.PI) / 10 - thetaPrime) +\n                3.07768 * Math.sin((2 * Math.PI) / 10 - thetaPrime))\n            );\n          } else {\n            return 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));\n          }\n        };\n        break;\n    }\n  }\n\n  /* Make sure gridSize is a whole number and is not smaller than 4px */\n  settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\n\n  /* shorthand */\n  var g = settings.gridSize;\n  var maskRectWidth = g - settings.maskGapWidth;\n\n  /* normalize rotation settings */\n  var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\n  var minRotation = Math.min(settings.maxRotation, settings.minRotation);\n  var rotationStep = settings.rotationStep;\n\n  /* information/object available to all functions, set when start() */\n  var grid, // 2d array containing filling information\n    ngx,\n    ngy, // width and height of the grid\n    center, // position of the center of the cloud\n    maxRadius;\n\n  /* timestamp for measuring each putWord() action */\n  var escapeTime;\n\n  /* function for getting the color of the text */\n  var getTextColor;\n  function randomHslColor(min, max) {\n    return (\n      'hsl(' +\n      (Math.random() * 360).toFixed() +\n      ',' +\n      (Math.random() * 30 + 70).toFixed() +\n      '%,' +\n      (Math.random() * (max - min) + min).toFixed() +\n      '%)'\n    );\n  }\n  switch (settings.color) {\n    case 'random-dark':\n      getTextColor = function getRandomDarkColor() {\n        return randomHslColor(10, 50);\n      };\n      break;\n\n    case 'random-light':\n      getTextColor = function getRandomLightColor() {\n        return randomHslColor(50, 90);\n      };\n      break;\n\n    default:\n      if (typeof settings.color === 'function') {\n        getTextColor = settings.color;\n      }\n      break;\n  }\n\n  /* function for getting the font-weight of the text */\n  var getTextFontWeight;\n  if (typeof settings.fontWeight === 'function') {\n    getTextFontWeight = settings.fontWeight;\n  }\n\n  /* function for getting the classes of the text */\n  var getTextClasses = null;\n  if (typeof settings.classes === 'function') {\n    getTextClasses = settings.classes;\n  }\n\n  /* Interactive */\n  var interactive = false;\n  var infoGrid = [];\n  var hovered;\n\n  var getInfoGridFromMouseTouchEvent = function getInfoGridFromMouseTouchEvent(\n    evt\n  ) {\n    var canvas = evt.currentTarget;\n    var rect = canvas.getBoundingClientRect();\n    var clientX;\n    var clientY;\n    /** Detect if touches are available */\n    if (evt.touches) {\n      clientX = evt.touches[0].clientX;\n      clientY = evt.touches[0].clientY;\n    } else {\n      clientX = evt.clientX;\n      clientY = evt.clientY;\n    }\n    var eventX = clientX - rect.left;\n    var eventY = clientY - rect.top;\n\n    var x = Math.floor((eventX * (canvas.width / rect.width || 1)) / g);\n    var y = Math.floor((eventY * (canvas.height / rect.height || 1)) / g);\n\n    if (!infoGrid[x]) {\n      return null\n    }\n\n    return infoGrid[x][y];\n  };\n\n  var wordcloudhover = function wordcloudhover(evt) {\n    var info = getInfoGridFromMouseTouchEvent(evt);\n\n    if (hovered === info) {\n      return;\n    }\n\n    hovered = info;\n    if (!info) {\n      settings.hover(undefined, undefined, evt);\n\n      return;\n    }\n\n    settings.hover(info.item, info.dimension, evt);\n  };\n\n  var wordcloudclick = function wordcloudclick(evt) {\n    var info = getInfoGridFromMouseTouchEvent(evt);\n    if (!info) {\n      return;\n    }\n\n    settings.click(info.item, info.dimension, evt);\n    evt.preventDefault();\n  };\n\n  /* Get points on the grid for a given radius away from the center */\n  var pointsAtRadius = [];\n  var getPointsAtRadius = function getPointsAtRadius(radius) {\n    if (pointsAtRadius[radius]) {\n      return pointsAtRadius[radius];\n    }\n\n    // Look for these number of points on each radius\n    var T = radius * 8;\n\n    // Getting all the points at this radius\n    var t = T;\n    var points = [];\n\n    if (radius === 0) {\n      points.push([center[0], center[1], 0]);\n    }\n\n    while (t--) {\n      // distort the radius to put the cloud in shape\n      var rx = 1;\n      if (settings.shape !== 'circle') {\n        rx = settings.shape((t / T) * 2 * Math.PI); // 0 to 1\n      }\n\n      // Push [x, y, t]; t is used solely for getTextColor()\n      points.push([\n        center[0] + radius * rx * Math.cos((-t / T) * 2 * Math.PI),\n        center[1] +\n          radius * rx * Math.sin((-t / T) * 2 * Math.PI) * settings.ellipticity,\n        (t / T) * 2 * Math.PI\n      ]);\n    }\n\n    pointsAtRadius[radius] = points;\n    return points;\n  };\n\n  /* Return true if we had spent too much time */\n  var exceedTime = function exceedTime() {\n    return (\n      settings.abortThreshold > 0 &&\n      new Date().getTime() - escapeTime > settings.abortThreshold\n    );\n  };\n\n  /* Get the deg of rotation according to settings, and luck. */\n  var getRotateDeg = function getRotateDeg() {\n    if (settings.rotateRatio === 0) {\n      return 0;\n    }\n\n    if (Math.random() > settings.rotateRatio) {\n      return 0;\n    }\n\n    if (rotationRange === 0) {\n      return minRotation;\n    }\n\n    return minRotation + Math.round(Math.random() * rotationRange / rotationStep) * rotationStep;\n  };\n\n  var getTextInfo = function getTextInfo(\n    word,\n    weight,\n    rotateDeg,\n    extraDataArray\n  ) {\n    // calculate the acutal font size\n    // fontSize === 0 means weightFactor function wants the text skipped,\n    // and size < minSize means we cannot draw the text.\n    var debug = false;\n    var fontSize = settings.weightFactor(weight);\n    if (fontSize <= settings.minSize) {\n      return false;\n    }\n\n    // Scale factor here is to make sure fillText is not limited by\n    // the minium font size set by browser.\n    // It will always be 1 or 2n.\n    var mu = 1;\n    if (fontSize < minFontSize) {\n      mu = (function calculateScaleFactor() {\n        var mu = 2;\n        while (mu * fontSize < minFontSize) {\n          mu += 2;\n        }\n        return mu;\n      })();\n    }\n\n    // Get fontWeight that will be used to set fctx.font\n    var fontWeight;\n    if (getTextFontWeight) {\n      fontWeight = getTextFontWeight(word, weight, fontSize, extraDataArray);\n    } else {\n      fontWeight = settings.fontWeight;\n    }\n\n    var fcanvas = document.createElement('canvas');\n    var fctx = fcanvas.getContext('2d', { willReadFrequently: true });\n\n    fctx.font =\n      fontWeight +\n      ' ' +\n      (fontSize * mu).toString(10) +\n      'px ' +\n      settings.fontFamily;\n\n    // Estimate the dimension of the text with measureText().\n    var fw = fctx.measureText(word).width / mu;\n    var fh =\n      Math.max(\n        fontSize * mu,\n        fctx.measureText('m').width,\n        fctx.measureText('\\uFF37').width\n      ) / mu;\n\n    // Create a boundary box that is larger than our estimates,\n    // so text don't get cut of (it sill might)\n    var boxWidth = fw + fh * 2;\n    var boxHeight = fh * 3;\n    var fgw = Math.ceil(boxWidth / g);\n    var fgh = Math.ceil(boxHeight / g);\n    boxWidth = fgw * g;\n    boxHeight = fgh * g;\n\n    // Calculate the proper offsets to make the text centered at\n    // the preferred position.\n\n    // This is simply half of the width.\n    var fillTextOffsetX = -fw / 2;\n    // Instead of moving the box to the exact middle of the preferred\n    // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n    // vertical centered.\n    var fillTextOffsetY = -fh * 0.4;\n\n    // Calculate the actual dimension of the canvas, considering the rotation.\n    var cgh = Math.ceil(\n      (boxWidth * Math.abs(Math.sin(rotateDeg)) +\n        boxHeight * Math.abs(Math.cos(rotateDeg))) /\n        g\n    );\n    var cgw = Math.ceil(\n      (boxWidth * Math.abs(Math.cos(rotateDeg)) +\n        boxHeight * Math.abs(Math.sin(rotateDeg))) /\n        g\n    );\n    var width = cgw * g;\n    var height = cgh * g;\n\n    fcanvas.setAttribute('width', width);\n    fcanvas.setAttribute('height', height);\n\n    if (debug) {\n      // Attach fcanvas to the DOM\n      document.body.appendChild(fcanvas);\n      // Save it's state so that we could restore and draw the grid correctly.\n      fctx.save();\n    }\n\n    // Scale the canvas with |mu|.\n    fctx.scale(1 / mu, 1 / mu);\n    fctx.translate((width * mu) / 2, (height * mu) / 2);\n    fctx.rotate(-rotateDeg);\n\n    // Once the width/height is set, ctx info will be reset.\n    // Set it again here.\n    fctx.font =\n      fontWeight +\n      ' ' +\n      (fontSize * mu).toString(10) +\n      'px ' +\n      settings.fontFamily;\n\n    // Fill the text into the fcanvas.\n    // XXX: We cannot because textBaseline = 'top' here because\n    // Firefox and Chrome uses different default line-height for canvas.\n    // Please read https://bugzil.la/737852#c6.\n    // Here, we use textBaseline = 'middle' and draw the text at exactly\n    // 0.5 * fontSize lower.\n    fctx.fillStyle = '#000';\n    fctx.textBaseline = 'middle';\n    fctx.fillText(\n      word,\n      fillTextOffsetX * mu,\n      (fillTextOffsetY + fontSize * 0.5) * mu\n    );\n\n    // Get the pixels of the text\n    var imageData = fctx.getImageData(0, 0, width, height).data;\n\n    if (exceedTime()) {\n      return false;\n    }\n\n    if (debug) {\n      // Draw the box of the original estimation\n      fctx.strokeRect(fillTextOffsetX * mu, fillTextOffsetY, fw * mu, fh * mu);\n      fctx.restore();\n    }\n\n    // Read the pixels and save the information to the occupied array\n    var occupied = [];\n    var gx = cgw;\n    var gy, x, y;\n    var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\n    while (gx--) {\n      gy = cgh;\n      while (gy--) {\n        y = g;\n        /* eslint no-labels: ['error', { 'allowLoop': true }] */\n        singleGridLoop: while (y--) {\n          x = g;\n          while (x--) {\n            if (imageData[((gy * g + y) * width + (gx * g + x)) * 4 + 3]) {\n              occupied.push([gx, gy]);\n\n              if (gx < bounds[3]) {\n                bounds[3] = gx;\n              }\n              if (gx > bounds[1]) {\n                bounds[1] = gx;\n              }\n              if (gy < bounds[0]) {\n                bounds[0] = gy;\n              }\n              if (gy > bounds[2]) {\n                bounds[2] = gy;\n              }\n\n              if (debug) {\n                fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n              }\n              break singleGridLoop;\n            }\n          }\n        }\n        if (debug) {\n          fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n          fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n        }\n      }\n    }\n\n    if (debug) {\n      fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n      fctx.fillRect(\n        bounds[3] * g,\n        bounds[0] * g,\n        (bounds[1] - bounds[3] + 1) * g,\n        (bounds[2] - bounds[0] + 1) * g\n      );\n    }\n\n    // Return information needed to create the text on the real canvas\n    return {\n      mu: mu,\n      occupied: occupied,\n      bounds: bounds,\n      gw: cgw,\n      gh: cgh,\n      fillTextOffsetX: fillTextOffsetX,\n      fillTextOffsetY: fillTextOffsetY,\n      fillTextWidth: fw,\n      fillTextHeight: fh,\n      fontSize: fontSize\n    };\n  };\n\n  /* Determine if there is room available in the given dimension */\n  var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\n    // Go through the occupied points,\n    // return false if the space is not available.\n    var i = occupied.length;\n    while (i--) {\n      var px = gx + occupied[i][0];\n      var py = gy + occupied[i][1];\n\n      if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n        if (!settings.drawOutOfBound) {\n          return false;\n        }\n        continue;\n      }\n\n      if (!grid[px][py]) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  /* Actually draw the text on the grid */\n  var drawText = function drawText(\n    gx,\n    gy,\n    info,\n    word,\n    weight,\n    distance,\n    theta,\n    rotateDeg,\n    attributes,\n    extraDataArray\n  ) {\n    var fontSize = info.fontSize;\n    var color;\n    if (getTextColor) {\n      color = getTextColor(\n        word,\n        weight,\n        fontSize,\n        distance,\n        theta,\n        extraDataArray\n      );\n    } else {\n      color = settings.color;\n    }\n\n    // get fontWeight that will be used to set ctx.font and font style rule\n    var fontWeight;\n    if (getTextFontWeight) {\n      fontWeight = getTextFontWeight(word, weight, fontSize, extraDataArray);\n    } else {\n      fontWeight = settings.fontWeight;\n    }\n\n    var classes;\n    if (getTextClasses) {\n      classes = getTextClasses(word, weight, fontSize, extraDataArray);\n    } else {\n      classes = settings.classes;\n    }\n\n    elements.forEach(function (el) {\n      if (el.getContext) {\n        var ctx = el.getContext('2d');\n        var mu = info.mu;\n\n        // Save the current state before messing it\n        ctx.save();\n        ctx.scale(1 / mu, 1 / mu);\n\n        ctx.font =\n          fontWeight +\n          ' ' +\n          (fontSize * mu).toString(10) +\n          'px ' +\n          settings.fontFamily;\n        ctx.fillStyle = color;\n\n        // Translate the canvas position to the origin coordinate of where\n        // the text should be put.\n        ctx.translate((gx + info.gw / 2) * g * mu, (gy + info.gh / 2) * g * mu);\n\n        if (rotateDeg !== 0) {\n          ctx.rotate(-rotateDeg);\n        }\n\n        // Finally, fill the text.\n\n        // XXX: We cannot because textBaseline = 'top' here because\n        // Firefox and Chrome uses different default line-height for canvas.\n        // Please read https://bugzil.la/737852#c6.\n        // Here, we use textBaseline = 'middle' and draw the text at exactly\n        // 0.5 * fontSize lower.\n        ctx.textBaseline = 'middle';\n        ctx.fillText(\n          word,\n          info.fillTextOffsetX * mu,\n          (info.fillTextOffsetY + fontSize * 0.5) * mu\n        );\n\n        // The below box is always matches how <span>s are positioned\n        /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n            info.fillTextWidth, info.fillTextHeight); */\n\n        // Restore the state.\n        ctx.restore();\n      } else {\n        // drawText on DIV element\n        var span = document.createElement('span');\n        var transformRule = '';\n        transformRule = 'rotate(' + (-rotateDeg / Math.PI) * 180 + 'deg) ';\n        if (info.mu !== 1) {\n          transformRule +=\n            'translateX(-' +\n            info.fillTextWidth / 4 +\n            'px) ' +\n            'scale(' +\n            1 / info.mu +\n            ')';\n        }\n        var styleRules = {\n          position: 'absolute',\n          display: 'block',\n          font:\n            fontWeight + ' ' + fontSize * info.mu + 'px ' + settings.fontFamily,\n          left: (gx + info.gw / 2) * g + info.fillTextOffsetX + 'px',\n          top: (gy + info.gh / 2) * g + info.fillTextOffsetY + 'px',\n          width: info.fillTextWidth + 'px',\n          height: info.fillTextHeight + 'px',\n          lineHeight: fontSize + 'px',\n          whiteSpace: 'nowrap',\n          transform: transformRule,\n          webkitTransform: transformRule,\n          msTransform: transformRule,\n          transformOrigin: '50% 40%',\n          webkitTransformOrigin: '50% 40%',\n          msTransformOrigin: '50% 40%'\n        };\n        if (color) {\n          styleRules.color = color;\n        }\n        span.textContent = word;\n        for (var cssProp in styleRules) {\n          span.style[cssProp] = styleRules[cssProp];\n        }\n        if (attributes) {\n          for (var attribute in attributes) {\n            span.setAttribute(attribute, attributes[attribute]);\n          }\n        }\n        if (classes) {\n          span.className += classes;\n        }\n        el.appendChild(span);\n      }\n    });\n  };\n\n  /* Help function to updateGrid */\n  var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\n    if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n      return;\n    }\n\n    grid[x][y] = false;\n\n    if (drawMask) {\n      var ctx = elements[0].getContext('2d');\n      ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\n    }\n\n    if (interactive) {\n      infoGrid[x][y] = { item: item, dimension: dimension };\n    }\n  };\n\n  /* Update the filling information of the given space with occupied points.\n       Draw the mask on the canvas if necessary. */\n  var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {\n    var occupied = info.occupied;\n    var drawMask = settings.drawMask;\n    var ctx;\n    if (drawMask) {\n      ctx = elements[0].getContext('2d');\n      ctx.save();\n      ctx.fillStyle = settings.maskColor;\n    }\n\n    var dimension;\n    if (interactive) {\n      var bounds = info.bounds;\n      dimension = {\n        x: (gx + bounds[3]) * g,\n        y: (gy + bounds[0]) * g,\n        w: (bounds[1] - bounds[3] + 1) * g,\n        h: (bounds[2] - bounds[0] + 1) * g\n      };\n    }\n\n    var i = occupied.length;\n    while (i--) {\n      var px = gx + occupied[i][0];\n      var py = gy + occupied[i][1];\n\n      if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n        continue;\n      }\n\n      fillGridAt(px, py, drawMask, dimension, item);\n    }\n\n    if (drawMask) {\n      ctx.restore();\n    }\n  };\n\n  /* putWord() processes each item on the list,\n       calculate it's size and determine it's position, and actually\n       put it on the canvas. */\n  var putWord = function putWord(item, loopIndex) {\n    if (loopIndex > 20) {\n      return null;\n    }\n\n    var word, weight, attributes;\n    if (Array.isArray(item)) {\n      word = item[0];\n      weight = item[1];\n    } else {\n      word = item.word;\n      weight = item.weight;\n      attributes = item.attributes;\n    }\n    var rotateDeg = getRotateDeg();\n\n    var extraDataArray = getItemExtraData(item);\n\n    // get info needed to put the text onto the canvas\n    var info = getTextInfo(word, weight, rotateDeg, extraDataArray);\n\n    // not getting the info means we shouldn't be drawing this one.\n    if (!info) {\n      return false;\n    }\n\n    if (exceedTime()) {\n      return false;\n    }\n\n    // If drawOutOfBound is set to false,\n    // skip the loop if we have already know the bounding box of\n    // word is larger than the canvas.\n    if (!settings.drawOutOfBound && !settings.shrinkToFit) {\n      var bounds = info.bounds;\n      if (bounds[1] - bounds[3] + 1 > ngx || bounds[2] - bounds[0] + 1 > ngy) {\n        return false;\n      }\n    }\n\n    // Determine the position to put the text by\n    // start looking for the nearest points\n    var r = maxRadius + 1;\n\n    var tryToPutWordAtPoint = function (gxy) {\n      var gx = Math.floor(gxy[0] - info.gw / 2);\n      var gy = Math.floor(gxy[1] - info.gh / 2);\n      var gw = info.gw;\n      var gh = info.gh;\n\n      // If we cannot fit the text at this position, return false\n      // and go to the next position.\n      if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n        return false;\n      }\n\n      // Actually put the text on the canvas\n      drawText(\n        gx,\n        gy,\n        info,\n        word,\n        weight,\n        maxRadius - r,\n        gxy[2],\n        rotateDeg,\n        attributes,\n        extraDataArray\n      );\n\n      // Mark the spaces on the grid as filled\n      updateGrid(gx, gy, gw, gh, info, item);\n\n      return {\n        gx: gx,\n        gy: gy,\n        rot: rotateDeg,\n        info: info\n      };\n    };\n\n    while (r--) {\n      var points = getPointsAtRadius(maxRadius - r);\n\n      if (settings.shuffle) {\n        points = [].concat(points);\n        shuffleArray(points);\n      }\n\n      // Try to fit the words by looking at each point.\n      // array.some() will stop and return true\n      // when putWordAtPoint() returns true.\n      for (var i = 0; i < points.length; i++) {\n        var res = tryToPutWordAtPoint(points[i]);\n        if (res) {\n          return res;\n        }\n      }\n\n      // var drawn = points.some(tryToPutWordAtPoint);\n      // if (drawn) {\n      //   // leave putWord() and return true\n      //   return true;\n      // }\n    }\n\n    if (settings.shrinkToFit) {\n      if (Array.isArray(item)) {\n        item[1] = (item[1] * 3) / 4;\n      } else {\n        item.weight = (item.weight * 3) / 4;\n      }\n      return putWord(item, loopIndex + 1);\n    }\n\n    // we tried all distances but text won't fit, return null\n    return null;\n  };\n\n  /* Send DOM event to all elements. Will stop sending event and return\n       if the previous one is canceled (for cancelable events). */\n  var sendEvent = function sendEvent(type, cancelable, details) {\n    if (cancelable) {\n      return !elements.some(function (el) {\n        var event = new CustomEvent(type, {\n          detail: details || {}\n        });\n        return !el.dispatchEvent(event);\n      }, this);\n    } else {\n      elements.forEach(function (el) {\n        var event = new CustomEvent(type, {\n          detail: details || {}\n        });\n        el.dispatchEvent(event);\n      }, this);\n    }\n  };\n\n  /* Start drawing on a canvas */\n  var start = function start() {\n    // For dimensions, clearCanvas etc.,\n    // we only care about the first element.\n    var canvas = elements[0];\n\n    if (canvas.getContext) {\n      ngx = Math.ceil(canvas.width / g);\n      ngy = Math.ceil(canvas.height / g);\n    } else {\n      var rect = canvas.getBoundingClientRect();\n      ngx = Math.ceil(rect.width / g);\n      ngy = Math.ceil(rect.height / g);\n    }\n\n    // Sending a wordcloudstart event which cause the previous loop to stop.\n    // Do nothing if the event is canceled.\n    if (!sendEvent('wordcloudstart', true)) {\n      return;\n    }\n\n    // Determine the center of the word cloud\n    center = settings.origin\n      ? [settings.origin[0] / g, settings.origin[1] / g]\n      : [ngx / 2, ngy / 2];\n\n    // Maxium radius to look for space\n    maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\n\n    /* Clear the canvas only if the clearCanvas is set,\n         if not, update the grid to the current canvas state */\n    grid = [];\n\n    var gx, gy, i;\n    if (!canvas.getContext || settings.clearCanvas) {\n      elements.forEach(function (el) {\n        if (el.getContext) {\n          var ctx = el.getContext('2d');\n          ctx.fillStyle = settings.backgroundColor;\n          ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n          ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n        } else {\n          el.textContent = '';\n          el.style.backgroundColor = settings.backgroundColor;\n          el.style.position = 'relative';\n        }\n      });\n\n      /* fill the grid with empty state */\n      gx = ngx;\n      while (gx--) {\n        grid[gx] = [];\n        gy = ngy;\n        while (gy--) {\n          grid[gx][gy] = true;\n        }\n      }\n    } else {\n      /* Determine bgPixel by creating\n           another canvas and fill the specified background color. */\n      var bctx = document.createElement('canvas').getContext('2d');\n\n      bctx.fillStyle = settings.backgroundColor;\n      bctx.fillRect(0, 0, 1, 1);\n      var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\n\n      /* Read back the pixels of the canvas we got to tell which part of the\n           canvas is empty.\n           (no clearCanvas only works with a canvas, not divs) */\n      var imageData = canvas\n        .getContext('2d')\n        .getImageData(0, 0, ngx * g, ngy * g).data;\n\n      gx = ngx;\n      var x, y;\n      while (gx--) {\n        grid[gx] = [];\n        gy = ngy;\n        while (gy--) {\n          y = g;\n          /* eslint no-labels: ['error', { 'allowLoop': true }] */\n          singleGridLoop: while (y--) {\n            x = g;\n            while (x--) {\n              i = 4;\n              while (i--) {\n                if (\n                  imageData[((gy * g + y) * ngx * g + (gx * g + x)) * 4 + i] !==\n                  bgPixel[i]\n                ) {\n                  grid[gx][gy] = false;\n                  break singleGridLoop;\n                }\n              }\n            }\n          }\n          if (grid[gx][gy] !== false) {\n            grid[gx][gy] = true;\n          }\n        }\n      }\n\n      imageData = bctx = bgPixel = undefined;\n    }\n\n    // fill the infoGrid with empty state if we need it\n    if (settings.hover || settings.click) {\n      interactive = true;\n\n      /* fill the grid with empty state */\n      gx = ngx + 1;\n      while (gx--) {\n        infoGrid[gx] = [];\n      }\n\n      if (settings.hover) {\n        canvas.addEventListener('mousemove', wordcloudhover);\n      }\n\n      if (settings.click) {\n        canvas.addEventListener('click', wordcloudclick);\n        canvas.addEventListener('touchstart', wordcloudclick);\n        canvas.addEventListener('touchend', function (e) {\n          e.preventDefault();\n        });\n        canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n      }\n\n      canvas.addEventListener('wordcloudstart', function stopInteraction() {\n        canvas.removeEventListener('wordcloudstart', stopInteraction);\n\n        canvas.removeEventListener('mousemove', wordcloudhover);\n        canvas.removeEventListener('click', wordcloudclick);\n        hovered = undefined;\n      });\n    }\n\n    i = 0;\n    var loopingFunction, stoppingFunction;\n    var layouting = true;\n    if (!settings.layoutAnimation) {\n      loopingFunction = function (cb) {\n        cb();\n      };\n      stoppingFunction = function () {\n        layouting = false;\n      };\n    } else if (settings.wait !== 0) {\n      loopingFunction = window.setTimeout;\n      stoppingFunction = window.clearTimeout;\n    } else {\n      loopingFunction = window.setImmediate;\n      stoppingFunction = window.clearImmediate;\n    }\n\n    var addEventListener = function addEventListener(type, listener) {\n      elements.forEach(function (el) {\n        el.addEventListener(type, listener);\n      }, this);\n    };\n\n    var removeEventListener = function removeEventListener(type, listener) {\n      elements.forEach(function (el) {\n        el.removeEventListener(type, listener);\n      }, this);\n    };\n\n    var anotherWordCloudStart = function anotherWordCloudStart() {\n      removeEventListener('wordcloudstart', anotherWordCloudStart);\n      stoppingFunction(timer[timerId]);\n    };\n\n    addEventListener('wordcloudstart', anotherWordCloudStart);\n\n    // At least wait the following code before call the first iteration.\n    timer[timerId] = (settings.layoutAnimation ? loopingFunction : setTimeout)(\n      function loop() {\n        if (!layouting) {\n          return;\n        }\n        if (i >= settings.list.length) {\n          stoppingFunction(timer[timerId]);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n          delete timer[timerId];\n          return;\n        }\n        escapeTime = new Date().getTime();\n        var drawn = putWord(settings.list[i], 0);\n        var canceled = !sendEvent('wordclouddrawn', true, {\n          item: settings.list[i],\n          drawn: drawn\n        });\n        if (exceedTime() || canceled) {\n          stoppingFunction(timer[timerId]);\n          settings.abort();\n          sendEvent('wordcloudabort', false);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n          return;\n        }\n        i++;\n        timer[timerId] = loopingFunction(loop, settings.wait);\n      },\n      settings.wait\n    );\n  };\n\n  // All set, start the drawing\n  start();\n};\n\nWordCloud.isSupported = isSupported;\nWordCloud.minFontSize = minFontSize;\n\nexport default WordCloud;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}